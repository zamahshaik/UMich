
# coding: utf-8

# ### Part 1 - Random Graph Identification
# 
# For the first part of this assignment you will analyze randomly generated graphs and determine which algorithm created them.

# In[1]:


# %matplotlib notebook
import networkx as nx
import pandas as pd
import numpy as np
import pickle
# import matplotlib.pyplot as plt


# In[2]:


P1_Graphs = pickle.load(open('A4_graphs','rb'))
P1_Graphs


# In[ ]:


# P1_Graphs is a list containing 5 networkx graphs. Each of these graphs were generated by 
# one of three possible algorithms:

#     Preferential Attachment ('PA')
#     Small World with low probability of rewiring ('SW_L')
#     Small World with high probability of rewiring ('SW_H')

# Anaylze each of the 5 graphs and determine which of the three algorithms generated the graph.

# The graph_identification function should return a list of length 5 where each element in the 
# list is either 'PA', 'SW_L', or 'SW_H'.


# In[3]:


# def degreeS(G):
# #     plt.close()
#     degrees = G.degree()
#     degree_values = sorted(set(degrees.values()))
#     histogram = [list(degrees.values()).count(i)/float(nx.number_of_nodes(G)) for i in degree_values]
#     plt.bar(degree_values, histogram)
#     plt.xlabel('Degree')
#     plt.ylabel('Fraction Of Nodes')
#     plt.show()
#     return histogram


# In[4]:


# degreeS(P1_Graphs[1])


# In[3]:


def degree_distribution(G):
    degrees = G.degree()
    degree_values = sorted(set(degrees.values()))
    return degree_values


# In[6]:


# degree_distribution(P1_Graphs[1])


# In[4]:


def graph_identification():
    graphs = []
    for G in P1_Graphs:
        avg_short_path = nx.average_shortest_path_length(G)
        avg_clus_coeff = nx.average_clustering(G)
        degree_dist = degree_distribution(G)
        if len(degree_dist) > 10:
            graphs.append('PA')
        elif avg_clus_coeff < 0.4:
            graphs.append('SW_H')
        else:
            graphs.append('SW_L')
    return graphs


# In[5]:


# graph_identification()


# In[11]:


# for G in P1_Graphs:
#     print(G)
    
# ['PA', 'SW_H', 'SW_L', 'PA', 'SW_L']
# ['PA', 'SW_H', 'SW_H', 'PA', 'SW_L']


# ### Part 2 - Company Emails
# 
# For the second part of this assignment you will be workking with a company's email network where each node corresponds to a person at the company, and each edge indicates that at least one email has been sent between two people.
# 
# The network also contains the node attributes Department and ManagementSalary.
# 
# Department indicates the department in the company which the person belongs to, and ManagementSalary indicates whether that person is receiving a management position salary.

# In[6]:


G = nx.read_gpickle('email_prediction.txt')

print(nx.info(G))


# ### Part 2A - Salary Prediction
# 
# Using network G, identify the people in the network with missing values for the node attribute ManagementSalary and predict whether or not these individuals are receiving a management position salary.
# 
# To accomplish this, you will need to create a matrix of node features using networkx, train a sklearn classifier on nodes that have ManagementSalary data, and predict a probability of the node receiving a management salary for nodes where ManagementSalary is missing.
# 
# Your predictions will need to be given as the probability that the corresponding employee is receiving a management position salary.
# 
# The evaluation metric for this assignment is the Area Under the ROC Curve (AUC).
# 
# Your grade will be based on the AUC score computed for your classifier. A model which with an AUC of 0.88 or higher will receive full points, and with an AUC of 0.82 or higher will pass (get 80% of the full points).
# 
# Using your trained classifier, return a series of length 252 with the data being the probability of receiving management salary, and the index being the node id.

# In[ ]:


# Graph properties
# nx.is_connected(G)
# nx.is_directed(G)
# nx.number_connected_components(G)
# sorted(nx.connected_components(G))

# Graph is undirected and disconnected with 19 nodes not sharing an edge with any other node.


# In[7]:


from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import auc

def salary_predictions():
    
    df = pd.DataFrame(index = G.nodes())
    df['degree'] = pd.Series(nx.degree(G))
    df['degree_centrality'] = pd.Series(nx.degree_centrality(G))
    df['closeness'] = pd.Series(nx.closeness_centrality(G, normalized = True))
    df['betweenness'] = pd.Series(nx.betweenness_centrality(G, normalized = True))
    df['page_rank'] = pd.Series(nx.pagerank(G))
    df['clustering'] = pd.Series(nx.clustering(G))
    df['Mgmtnode'] = pd.Series([0 if y['ManagementSalary'] == 0 else 
                                1 if y['ManagementSalary'] == 1 else 
                                None for x, y in G.nodes(data = True)])
    features = ['degree', 'degree_centrality', 'closeness', 'betweenness', 'page_rank', 'clustering']

    df_train = df[~pd.isnull(df['Mgmtnode'])]
    df_test = df[pd.isnull(df['Mgmtnode'])]

    X_train = df_train[features]
    y_train = df_train['Mgmtnode']
    X_test = df_test[features]

    scaler = MinMaxScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)

    logreg = LogisticRegression().fit(X_train_scaled, y_train)

    predictions = logreg.predict_proba(X_test_scaled)[:,1]
    
    return pd.Series(predictions, X_test.index)


# ### Part 2B - New Connections Prediction
# 
# For the last part of this assignment, you will predict future connections between employees of the network. The future connections information has been loaded into the variable future_connections. The index is a tuple indicating a pair of nodes that currently do not have a connection, and the Future Connection column indicates if an edge between those two nodes will exist in the future, where a value of 1.0 indicates a future connection.
# 
# Using network G and future_connections, identify the edges in future_connections with missing values and predict whether or not these edges will have a future connection.
# 
# To accomplish this, you will need to create a matrix of features for the edges found in future_connections using networkx, train a sklearn classifier on those edges in future_connections that have Future Connection data, and predict a probability of the edge being a future connection for those edges in future_connections where Future Connection is missing.
# 
# Your predictions will need to be given as the probability of the corresponding edge being a future connection.
# 
# The evaluation metric for this assignment is the Area Under the ROC Curve (AUC).
# 
# Your grade will be based on the AUC score computed for your classifier. A model which with an AUC of 0.88 or higher will receive full points, and with an AUC of 0.82 or higher will pass (get 80% of the full points).
# 
# Using your trained classifier, return a series of length 122112 with the data being the probability of the edge being a future connection, and the index being the edge

# In[8]:


future_connections = pd.read_csv('Future_Connections.csv', index_col=0, converters={0: eval})
future_connections.head(10)


# In[11]:


def new_connections_predictions():
    
    for i in G.nodes():
        G.node[i]['community'] = G.node[i]['Department']
    pref_attach = list(nx.preferential_attachment(G))
    df = pd.DataFrame(index = [(x[0],x[1]) for x in pref_attach])
    df['pref_attach'] = [x[2] for x in pref_attach]

    cn_sound_hopcr = list(nx.cn_soundarajan_hopcroft(G))
    df_cn_sound_hopcr = pd.DataFrame(index = [(x[0], x[1]) for x in cn_sound_hopcr])
    df_cn_sound_hopcr['cn_soundarajan_hopcroft'] = [x[2] for x in cn_sound_hopcr]

    df = df.join(df_cn_sound_hopcr, how = 'outer')

    df['resource_alloc'] = [x[2] for x in list(nx.resource_allocation_index(G))]
    df['jaccard'] = [x[2] for x in list(nx.jaccard_coefficient(G))]

    df = future_connections.join(df, how = 'outer')
    df.rename(columns = {'Future Connection': 'future_connection'}, inplace = True)

    df_train = df[~pd.isnull(df['future_connection'])]
    df_test = df[pd.isnull(df['future_connection'])]

    features = ['pref_attach', 'cn_soundarajan_hopcroft', 'resource_alloc', 'jaccard']
    X_train = df_train[features]
    y_train = df_train['future_connection']
    X_test = df_test[features]

    scaler = MinMaxScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)

    logreg = LogisticRegression().fit(X_train_scaled, y_train)

    predictions = logreg.predict_proba(X_test_scaled)[:,1]

    preds = pd.Series(predictions, X_test.index)

    futr_conns = future_connections[pd.isnull(future_connections['Future Connection'])]
    futr_conns['preds'] = [preds[x] for x in futr_conns.index]
    
    return futr_conns['preds']


# In[12]:


# new_connections_predictions()


# In[ ]:


# Function graph_identification was answered correctly, 0.2 points were awarded. Correct. 
# For the salary predictions your AUC 0.9222360592223606 was awarded a value of 0.4 out of 1.0 total grades 
# For the new connections predictions your AUC 0.9106642028280238 was awarded a value of 0.4 out of 1.0 total grades

